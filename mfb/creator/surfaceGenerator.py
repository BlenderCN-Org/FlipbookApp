import sys,os, time, glob, random, pickle, pdb, logging, pprint
import bpy, mathutils

def main(args):

	# parses argument from command
	cachePath, pdbid, chains, method = args[-4:]

	# sanitize input
	pdbid = pdbid.lower()

	# get MolKit per-chain centers
	fp = open(os.path.join(cachePath, pdbid, "centers"), mode='rb')
	chainsCenter = pickle.load(fp)

	fp = open(os.path.join(cachePath, pdbid, "matrix"), mode='rb')
	matrix = pickle.load(fp)
	pprint.pprint(matrix)


	for chain in chains.split():

		if 'msms' in method:
			logging.info('Generating Blender object ' + chain)

			# open geom files generated by msms
			verts = os.path.join(cachePath, pdbid, str(ord(chain))+"_0.vert")
			faces = os.path.join(cachePath, pdbid, str(ord(chain))+"_0.face")
			fileVerts = open(verts)
			fileFaces = open(faces)

			# load verts
			vertices = []
			for line in fileVerts:
				v = line.strip().split()[:3]
				v = tuple(map(float, v))
				vertices.append(v)

			# load faces
			faces = []
			for line in fileFaces:
				f = line.strip().split()[:3]
				f = [int(idx)-1 for idx in f]
				faces.append(f)


			if len(faces) == 0 or len(vertices) == 0:
				# raise Exception("No Data")
				continue
			else:
				# do not deal with bioMT matrices	
				name = pdbid+'_'+chain+'_msms'
				me = bpy.data.meshes.new(name)
				me.from_pydata(vertices, [], faces)
				obMSMS = bpy.data.objects.new(name, me)
				# set smooth
				for f in me.polygons:
					f.use_smooth = True

				addBPYObject(obMSMS, chainsCenter, chain)
			
				logging.info('Generated Blender object ' + obMSMS.name)



		if 'cms' in method:
			# open files generated by cms
			verts = os.path.join(cachePath, pdbid, "cms"+str(ord(chain))+".vert")
			faces = os.path.join(cachePath, pdbid, "cms"+str(ord(chain))+".face")
			fileVerts = open(verts, 'rb')
			fileFaces = open(faces, 'rb')
			v = pickle.load(fileVerts)
			f = pickle.load(fileFaces)

			status = "Surface Generator: %s %d vertices, %d faces"%(chain, len(v), len(f))
			logging.info(status)

			vertices = v.tolist()
			faces = f.tolist()
			
			if (len(v) == 0) and (len(f) == 0):
				# raise Exception("No Data")
				continue
			else:
				name = pdbid+'_'+chain+'_cms'
				me = bpy.data.meshes.new(name)
				me.from_pydata(vertices, [], faces)
				obCMS = bpy.data.objects.new(name, me)

				# set smooth
				for f in me.polygons:
					f.use_smooth = True

				if matrix:
					ob = addBPYObject(obCMS, chainsCenter, chain, centre = False)
				else:
					ob = addBPYObject(obCMS, chainsCenter, chain)


				logging.info('Generated Blender object ' + obCMS.name)

		else:
			raise Exception("Unexpected Surfacing method")


	bpy.ops.wm.save_mainfile(filepath = os.path.join(cachePath, pdbid, "geometry.blend"))


def addBPYObject(ob, chainsCenter, chain, centre=True):
	mat = bpy.data.materials.new(ob.name)
	random.seed(ob.name.split('.')[0])
	color3d = (random.random(), random.random(), random.random())
	mat.diffuse_color = (color3d)
	mat.specular_intensity = 0.0
	mat.diffuse_intensity = 1.0
	ob.data.materials.append(mat)

	# attach to scene and validate context
	scn = bpy.context.scene
	scn.objects.link(ob)
	scn.objects.active = ob
	ob.select = True

	# cleanup
	if False:
		bpy.ops.object.modifier_add(type='REMESH')
		remesh = ob.modifiers[-1]
		remesh.mode = 'SMOOTH'
		remesh.octree_depth = 5
		bpy.ops.object.modifier_apply(apply_as='DATA', modifier=remesh.name)
		bpy.ops.object.editmode_toggle()
		bpy.ops.mesh.select_all(action='SELECT')
	else:
		bpy.ops.object.editmode_toggle()
		bpy.ops.mesh.select_all(action='SELECT')
		bpy.ops.mesh.remove_doubles(threshold=0.1)
		bpy.ops.mesh.tris_convert_to_quads(limit=1.7)
		bpy.ops.mesh.tris_convert_to_quads(limit=3.1)
		bpy.ops.mesh.vertices_smooth(repeat=1)

	bpy.ops.uv.cube_project()
	bpy.ops.object.editmode_toggle()

	# origin
	if centre:
		bpy.context.scene.cursor_location = chainsCenter[chain]
		bpy.ops.object.origin_set(type="ORIGIN_CURSOR", center="MEDIAN")

	ob.select = False
	return ob



if __name__ == '__main__':

	start = time.time()
	main(sys.argv)
	end = time.time()
	logging.info("Mesh Importing time: %d"%(end-start))
